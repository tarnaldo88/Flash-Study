using FlashStudy.Models;
using SQLite;

namespace FlashStudy.Data;

public static class SeedData
{
    public static async Task EnsureGoDeckAsync(SQLiteAsyncConnection db)
    {
        var existing = await db.Table<Deck>()
            .Where(d => d.Name == "Golang")
            .FirstOrDefaultAsync();

        if (existing is not null)
        {
            return;
        }

        var now = DateTime.UtcNow;
        var deck = new Deck
        {
            Name = "Golang",
            CreatedAt = now,
            UpdatedAt = now
        };

        await db.InsertAsync(deck);

        var cards = new List<Card>
        {
            new() { DeckId = deck.Id, Front = "What is Go?", Back = "Go is a statically typed, compiled language designed for simplicity and concurrency. It emphasizes fast builds and straightforward tooling.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Who created Go?", Back = "Go was created at Google by Robert Griesemer, Rob Pike, and Ken Thompson. It was designed to improve developer productivity at scale.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a package in Go?", Back = "A package is a collection of source files in the same directory that share a package name. It is the basic unit of code organization and reuse.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the entry point of a Go program?", Back = "Execution starts in package main at the main function. Only package main with a main function produces an executable.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How do you declare a variable in Go?", Back = "You can use var name type or the short form name := value inside functions. The short form infers the type from the initializer.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is zero value in Go?", Back = "The zero value is the default value for uninitialized variables, such as 0, false, and \"\". It enables safe defaults without explicit initialization.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are Go's basic types?", Back = "Go includes bool, string, integer and unsigned integer types, floating point, complex, byte, and rune. These cover most primitive needs without implicit conversions.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a rune?", Back = "A rune is an alias for int32 representing a Unicode code point. It is commonly used when iterating over strings by characters.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a byte?", Back = "A byte is an alias for uint8 and represents raw binary data. It is often used for buffers and ASCII text.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a slice?", Back = "A slice is a dynamic view into an array with length and capacity. It is the idiomatic way to work with sequences in Go.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Slice length vs capacity.", Back = "Length is the number of elements currently in the slice. Capacity is how many elements it can grow to before reallocation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How do you create a slice?", Back = "You can use make([]T, len, cap) or slice an existing array. make allocates the backing array for you.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an array in Go?", Back = "An array is a fixed-size sequence of elements of the same type. Its length is part of its type, so [3]int and [4]int are different types.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How are arrays passed to functions?", Back = "Arrays are passed by value, meaning they are copied. Use a pointer or slice when you want to avoid copying or allow mutation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a map?", Back = "A map is a hash table that maps keys to values. It provides average O(1) lookup, insert, and delete.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to check if a key exists in a map?", Back = "Use the comma-ok idiom: v, ok := m[key]. ok is false if the key is missing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a struct?", Back = "A struct is a composite type that groups fields under one name. It is the primary way to model data structures in Go.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How do you define a method in Go?", Back = "Methods are functions with a receiver, e.g., func (r Receiver) Method(). The receiver can be a value or pointer type.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Pointer vs value receiver.", Back = "Pointer receivers can modify the original value and avoid copying large structs. Value receivers operate on a copy and are fine for small, immutable types.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an interface in Go?", Back = "An interface is a set of method signatures that a type can implement implicitly. This enables flexible composition and duck typing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Does Go have inheritance?", Back = "Go does not support classical inheritance. It favors composition and interfaces to share behavior.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is embedding in Go?", Back = "Embedding includes a type in a struct to promote its methods and fields. It is Go’s way to achieve composition with minimal boilerplate.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a goroutine?", Back = "A goroutine is a lightweight concurrent function managed by the Go runtime. It has low overhead compared to OS threads.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to start a goroutine?", Back = "Prefix a function call with go, as in go f(). The function runs concurrently with the caller.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a channel?", Back = "A channel is a typed conduit for communication between goroutines. It is used to synchronize and pass data safely.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Buffered vs unbuffered channels.", Back = "Unbuffered channels block until both sender and receiver are ready. Buffered channels allow a fixed number of queued values before blocking.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does closing a channel do?", Back = "Closing a channel signals that no more values will be sent. Receivers can range over it until it is drained.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to detect a closed channel?", Back = "Use the comma-ok idiom: v, ok := <-ch. ok is false when the channel is closed and drained.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is select in Go?", Back = "select waits on multiple channel operations and proceeds with the one that is ready. It is Go’s way to multiplex channel communication.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a nil channel behavior?", Back = "Sending to or receiving from a nil channel blocks forever. It is often used to disable select cases.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a race condition?", Back = "A race condition occurs when concurrent operations cause nondeterministic results. It often appears when shared data is accessed without synchronization.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to detect race conditions in Go?", Back = "Use the race detector with go test -race or go run -race. It instruments code to detect unsafe concurrent access.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is sync.Mutex for?", Back = "sync.Mutex provides mutual exclusion for shared data. It ensures only one goroutine accesses a critical section at a time.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is sync.WaitGroup?", Back = "sync.WaitGroup lets you wait for a set of goroutines to finish. You increment a counter and call Done when each goroutine completes.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is sync.Once?", Back = "sync.Once guarantees a function runs only once, even across multiple goroutines. It is commonly used for lazy initialization.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a context in Go?", Back = "A context carries cancellation signals, deadlines, and request-scoped values. It is used to control lifetimes of operations across API boundaries.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How do you cancel a context?", Back = "Create it with context.WithCancel and call the cancel function. That propagates cancellation to all derived contexts.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is defer used for?", Back = "defer schedules a function call to run when the surrounding function returns. It is often used for cleanup like closing files or unlocking mutexes.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is panic?", Back = "panic stops normal execution and begins unwinding the stack. It is used for unrecoverable errors, not routine control flow.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is recover?", Back = "recover regains control after a panic when called from a deferred function. It is used to handle panics gracefully in boundaries.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a type assertion?", Back = "A type assertion extracts the concrete value from an interface, e.g., v := x.(T). It panics if the assertion fails unless you use the comma-ok form.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a type switch?", Back = "A type switch branches based on the dynamic type of an interface value. It is a concise way to handle multiple concrete types.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is error type in Go?", Back = "The error type is an interface with a single method Error() string. It is Go’s conventional way to return failures.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How do you create a custom error?", Back = "Use errors.New or fmt.Errorf for simple errors, or define a type that implements Error(). Custom types can carry additional context.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is error wrapping?", Back = "Error wrapping adds context while preserving the original error, typically with fmt.Errorf(\"%w\", err). It enables inspection of error chains.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to check wrapped errors?", Back = "Use errors.Is to check for a specific error and errors.As to extract a specific type. They traverse the wrapped error chain safely.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is gofmt?", Back = "gofmt is the standard Go formatter that enforces consistent style. It is widely used in tooling and CI.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is go build?", Back = "go build compiles packages and their dependencies into binaries. It uses module metadata to resolve versions.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is go test?", Back = "go test runs unit tests and benchmarks in packages. It also builds the package to ensure code compiles.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is go mod?", Back = "go mod manages modules and dependencies via go.mod and go.sum. It enables reproducible builds across environments.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a Go module?", Back = "A Go module is a collection of related packages defined by a go.mod file. It is the standard unit of versioning and dependency management.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does go mod tidy do?", Back = "go mod tidy adds missing and removes unused dependencies. It keeps go.mod and go.sum clean and accurate.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is GOPATH?", Back = "GOPATH is the legacy workspace path for Go projects. It is less important with modules but still used for some tooling.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are generics in Go?", Back = "Generics add type parameters for reusable, type-safe code. They reduce boilerplate while preserving compile-time safety.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to declare a generic function?", Back = "Use type parameters like func F[T any](v T) T { return v }. Constraints control which types are allowed.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the empty interface?", Back = "interface{} can hold any value because it has no required methods. It is useful but loses type safety if overused.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is any?", Back = "any is an alias for interface{} introduced for readability. It behaves exactly the same.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a nil interface pitfall?", Back = "An interface with a typed nil value is not equal to nil. This can cause unexpected nil checks to pass incorrectly.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a pointer in Go?", Back = "A pointer holds the address of another value. It is used to avoid copying and to allow mutation of values.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How do you allocate with new?", Back = "new(T) allocates zeroed storage and returns *T. It is useful when you need a pointer to a zero value.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How do you allocate with make?", Back = "make initializes and returns slices, maps, and channels. It allocates the underlying data structures for you.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "make vs new.", Back = "new returns a pointer to zeroed memory, while make initializes built-in reference types. make returns a value, not a pointer.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a variadic function?", Back = "A variadic function accepts a variable number of arguments using .... It treats them as a slice inside the function.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is named return value?", Back = "Named return values declare return variables in the function signature. They can be set and returned implicitly, but should be used sparingly for clarity.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How does range work on slices?", Back = "range returns index and a copy of the element value. Mutating the loop variable does not change the underlying slice.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is shadowing?", Back = "Shadowing declares a new variable with the same name in an inner scope. It can be confusing, so use it carefully.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is init function?", Back = "init functions run automatically before main. They are used for package-level initialization when needed.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is package init order?", Back = "Dependencies initialize first, then package-level variables, then init functions. This order is deterministic across packages.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a build tag?", Back = "Build tags are directives that include files based on build constraints. They enable platform- or feature-specific code.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an interface embedding?", Back = "Interface embedding combines multiple interfaces into one. It allows composing behaviors without redefining methods.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is method set?", Back = "A method set is the set of methods a type has for interface satisfaction. It differs for value and pointer receivers.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a map zero value?", Back = "The zero value of a map is nil. Reads return zero values, but writes to a nil map panic.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to delete from a map?", Back = "Use delete(m, key) to remove an entry. Deleting a non-existent key is safe and has no effect.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is JSON marshaling?", Back = "JSON marshaling converts Go structs to JSON using encoding/json. It uses struct tags to control field names and options.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is struct tag in Go?", Back = "Struct tags are metadata in backticks used by reflection, like json:\"name\". They control serialization, validation, and other behaviors.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How do you read command-line args?", Back = "Use os.Args to access command-line arguments. The first element is the program name.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to read environment variables?", Back = "Use os.Getenv or os.LookupEnv to read environment variables. LookupEnv also tells you whether the variable is set.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is net/http used for?", Back = "net/http provides HTTP client and server implementations. It is the standard library package for building web services.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to create a basic HTTP server?", Back = "Use http.HandleFunc to register handlers and http.ListenAndServe to start the server. It binds to an address and serves requests.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a context deadline?", Back = "A context deadline is a time after which the context is automatically canceled. It is used to enforce timeouts on operations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is go routine leak?", Back = "A goroutine leak happens when a goroutine never exits, often due to blocked operations. It can accumulate and waste resources over time.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a worker pool?", Back = "A worker pool is a fixed set of goroutines processing jobs from a channel. It limits concurrency and controls resource usage.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is fan-in/fan-out?", Back = "Fan-in merges multiple channels into one, while fan-out distributes work across multiple goroutines. These patterns help parallelize and aggregate work.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is time.After used for?", Back = "time.After returns a channel that fires after a duration. It is commonly used for timeouts and delays.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a ticker?", Back = "A time.Ticker delivers periodic time events on a channel. It is used for repeated actions at fixed intervals.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is context.WithTimeout?", Back = "context.WithTimeout creates a context that cancels after a duration. It is a common way to apply timeouts to operations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a pointer receiver needed for?", Back = "Pointer receivers allow methods to modify the receiver and avoid copying large structs. They are also required to satisfy interfaces expecting pointer methods.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the blank identifier?", Back = "The blank identifier _ discards values you don’t need. It is commonly used to ignore errors or unused results.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is go vet?", Back = "go vet reports suspicious constructs and potential bugs. It complements tests by catching common mistakes.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the race detector flag?", Back = "Use -race with go test or go run to enable the race detector. It helps find data races in concurrent code.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is go generate?", Back = "go generate runs code generation commands specified by //go:generate comments. It is a build-time automation hook.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is cgo?", Back = "cgo allows calling C code from Go. It is useful for integrating with existing C libraries but adds build complexity.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is build constraint syntax?", Back = "Build constraints use //go:build lines (and legacy +build) to include files conditionally. They control platform- or feature-specific builds.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How to create a test in Go?", Back = "Write functions named TestXxx in *_test.go files. Use the testing package to run and assert behaviors.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is benchmarking in Go?", Back = "Go benchmarks use BenchmarkXxx functions in *_test.go files. Run them with go test -bench to measure performance.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is table-driven testing?", Back = "Table-driven testing defines multiple cases in a slice and loops over them. It keeps tests concise and easy to extend.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is go test -run?", Back = "go test -run executes tests matching a regex. It is useful for running a subset of tests.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is go test -bench?", Back = "go test -bench runs benchmarks matching a regex. It reports performance metrics like ns/op.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is Go's GC?", Back = "Go’s GC is a concurrent garbage collector that manages heap memory. It minimizes pauses while reclaiming unused objects.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is escape analysis?", Back = "Escape analysis decides whether variables are allocated on the stack or heap. It affects performance and garbage collection pressure.", CreatedAt = now, UpdatedAt = now }
        };
        await db.InsertAllAsync(cards);
    }
    
    public static async Task EnsureSoftwareEngineerDeckAsync(SQLiteAsyncConnection db)
    {
        var existing = await db.Table<Deck>()
            .Where(d => d.Name == "Software Engineer")
            .FirstOrDefaultAsync();
        
        if (existing is not null)
        {
            return;
        }

        var now = DateTime.UtcNow;
        var deck = new Deck
        {
          Name = "Software Engineer",
          CreatedAt = now,
          UpdatedAt = now  
        };

        await db.InsertAsync(deck);

        var cards = new List<Card>
        {
            new() { DeckId = deck.Id, Front = "What is Big-O notation?", Back = "Big-O describes how time or space grows as input size increases. It helps compare algorithm scalability independent of hardware.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Time complexity of binary search.", Back = "Binary search runs in O(log n) time on sorted data. It repeatedly halves the search space until the target is found or exhausted.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Time complexity of quicksort (average).", Back = "Quicksort is O(n log n) on average but can degrade to O(n^2) in the worst case. Good pivot selection and randomized input reduce the risk.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a hash table?", Back = "A hash table maps keys to values using a hash function. It offers average O(1) insert and lookup when the table is well-sized.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Stack vs queue.", Back = "A stack is LIFO, so the most recent item is removed first. A queue is FIFO, so items leave in the order they arrive.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is recursion?", Back = "Recursion is a function calling itself to solve smaller subproblems. It must have a base case to avoid infinite calls.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define immutability.", Back = "Immutability means an object’s state cannot change after it is created. It simplifies reasoning and reduces bugs in concurrent code.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a pure function?", Back = "A pure function has no side effects and always returns the same output for the same input. This makes it easier to test and compose.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "OOP pillars.", Back = "OOP relies on encapsulation, inheritance, polymorphism, and abstraction. Together they promote modularity and reusable design.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is dependency injection?", Back = "Dependency injection provides dependencies from outside a class rather than creating them internally. It improves testability and reduces coupling.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is SOLID?", Back = "SOLID is a set of design principles for maintainable object-oriented code. It guides class responsibilities, extensibility, and dependency management.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Single Responsibility Principle.", Back = "A class should have one reason to change. This keeps components focused and easier to maintain.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Open/Closed Principle.", Back = "Software should be open for extension but closed for modification. New behavior should be added without changing existing, tested code.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Liskov Substitution Principle.", Back = "Subtypes should be usable wherever their base type is expected without breaking behavior. It ensures inheritance preserves correctness.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Interface Segregation Principle.", Back = "Clients should not be forced to depend on methods they do not use. Prefer smaller, role-specific interfaces over large ones.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Dependency Inversion Principle.", Back = "High-level modules should depend on abstractions, not concrete implementations. This improves flexibility and testability.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is unit testing?", Back = "Unit testing validates small pieces of code in isolation. It helps catch regressions quickly and supports safe refactoring.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is integration testing?", Back = "Integration testing verifies interactions between multiple components. It catches issues that unit tests miss, such as misconfigured dependencies.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is TDD?", Back = "Test-driven development writes tests before implementing functionality. It encourages small, verifiable steps and improves design.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is code review?", Back = "Code review is peer evaluation of changes to ensure correctness, readability, and maintainability. It also spreads knowledge across the team.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is CI/CD?", Back = "CI/CD automates building, testing, and deploying code. It shortens feedback loops and reduces manual release risk.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a REST API?", Back = "A REST API exposes resources via HTTP using standard verbs like GET and POST. It emphasizes statelessness and resource-oriented URLs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is HTTP status 404?", Back = "HTTP 404 means the requested resource was not found. It indicates the server is reachable but the endpoint does not exist.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is HTTP status 500?", Back = "HTTP 500 indicates an internal server error. It signals an unhandled failure on the server side.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a race condition?", Back = "A race condition occurs when outcomes depend on timing between concurrent operations. It often leads to nondeterministic bugs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a deadlock?", Back = "A deadlock happens when two or more processes wait indefinitely for each other’s resources. Proper locking order and timeouts help prevent it.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a mutex?", Back = "A mutex is a lock that allows exclusive access to a resource. It prevents simultaneous modification by multiple threads.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an exception?", Back = "An exception represents an error that disrupts normal control flow. It should be used for exceptional conditions, not routine logic.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is garbage collection?", Back = "Garbage collection automatically reclaims memory from objects that are no longer referenced. It reduces manual memory management but can introduce pauses.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a build artifact?", Back = "A build artifact is the output of a build process, such as binaries, packages, or Docker images. It is what you deploy or distribute.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is semantic versioning?", Back = "Semantic versioning uses MAJOR.MINOR.PATCH to communicate breaking and non-breaking changes. It sets expectations for compatibility.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a code smell?", Back = "A code smell is a sign that code may be difficult to maintain or prone to bugs. It suggests refactoring, not necessarily a defect.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is refactoring?", Back = "Refactoring improves internal structure without changing behavior. It reduces technical debt and makes future changes safer.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a database index?", Back = "A database index is a data structure that speeds up queries. It improves read performance at the cost of extra storage and slower writes.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is normalization?", Back = "Normalization organizes relational data to reduce redundancy and anomalies. It improves consistency but can increase join complexity.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an ORM?", Back = "An ORM maps database tables to objects in code. It improves developer productivity but can hide inefficient queries if misused.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a feature flag?", Back = "A feature flag toggles functionality at runtime without redeploying. It enables safe rollouts and A/B testing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a backlog?", Back = "A backlog is a prioritized list of work items or user stories. It helps teams plan and sequence work based on value.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is Agile?", Back = "Agile is an iterative approach focused on collaboration, feedback, and adaptability. It emphasizes delivering value in small increments.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a sprint?", Back = "A sprint is a fixed time-box during which a team delivers a set of work. It provides cadence for planning and feedback.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a user story?", Back = "A user story describes a feature from the user’s perspective, often in a simple template. It focuses on value rather than implementation details.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a UML diagram?", Back = "A UML diagram visually models system components and relationships. It helps communicate design and structure across teams.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a design pattern?", Back = "A design pattern is a reusable solution to a recurring software design problem. It captures proven approaches in a named form.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the Factory pattern?", Back = "The Factory pattern creates objects without exposing instantiation logic to the client. It centralizes creation and supports polymorphism.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the Singleton pattern?", Back = "The Singleton pattern ensures a class has a single instance and provides a global access point. It can be useful but can also introduce hidden dependencies.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the Strategy pattern?", Back = "The Strategy pattern encapsulates interchangeable behaviors behind a common interface. It allows behavior to vary without changing clients.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the Observer pattern?", Back = "The Observer pattern notifies dependent objects when a subject changes. It enables event-driven designs and loose coupling.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the Adapter pattern?", Back = "The Adapter pattern converts one interface into another expected by clients. It allows incompatible components to work together.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is composition over inheritance?", Back = "Composition over inheritance favors building behavior from smaller objects rather than deep class hierarchies. It typically improves flexibility and testability.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a DTO?", Back = "A DTO carries data between layers without behavior. It helps define clear boundaries and contracts.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a repository pattern?", Back = "The repository pattern abstracts data access behind a collection-like interface. It improves testability and isolates persistence details.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an anti-pattern?", Back = "An anti-pattern is a common but counterproductive solution. It often looks reasonable at first but leads to long-term problems.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a lambda?", Back = "A lambda is an anonymous function that can be passed as a value. It is widely used in functional-style APIs and callbacks.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a closure?", Back = "A closure is a function that captures variables from its enclosing scope. It allows stateful behavior without explicit objects.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a null reference exception?", Back = "A null reference exception occurs when code accesses a member on a null object. It is a common runtime error avoided by null checks and type annotations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a memory leak?", Back = "A memory leak occurs when unused memory is not released. Over time it can degrade performance or crash a process.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a stack overflow?", Back = "A stack overflow happens when the call stack exceeds its limit, often due to deep or infinite recursion. It terminates the process or thread.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a database transaction?", Back = "A transaction is an atomic unit of work that either commits fully or rolls back. It ensures consistency when multiple operations must succeed together.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "ACID properties.", Back = "ACID stands for Atomicity, Consistency, Isolation, and Durability. These properties define the guarantees of reliable database transactions.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is eventual consistency?", Back = "Eventual consistency means replicas converge over time rather than immediately. It improves availability but can allow stale reads temporarily.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is optimistic locking?", Back = "Optimistic locking assumes low contention and detects conflicts at commit time. It improves concurrency but requires conflict handling.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is pessimistic locking?", Back = "Pessimistic locking locks data to prevent concurrent updates. It reduces conflicts but can lower throughput and increase blocking.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a codebase monorepo?", Back = "A monorepo stores multiple projects in a single repository. It simplifies cross-project changes but requires strong tooling and governance.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a service-level objective (SLO)?", Back = "An SLO is the reliability target for a service metric. It guides operational priorities and informs SLA commitments.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is technical debt?", Back = "Technical debt is the cost of shortcuts taken for speed. It accumulates interest in the form of slower development and higher risk.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a spike?", Back = "A spike is a time-boxed research task to reduce uncertainty. It produces learning rather than production code.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a retro?", Back = "A retrospective is a team meeting to reflect on what went well and what didn’t. It drives continuous process improvement.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a bug triage?", Back = "Bug triage prioritizes and assigns bugs based on impact and urgency. It ensures the most important issues are addressed first.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is observability?", Back = "Observability is understanding system behavior through logs, metrics, and traces. It enables faster debugging and performance tuning.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a distributed trace?", Back = "A distributed trace follows a request across multiple services. It helps identify latency bottlenecks and failures in complex systems.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an SRE?", Back = "An SRE is a Site Reliability Engineer who applies software practices to operations. The role balances reliability, automation, and service performance.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is infrastructure as code?", Back = "Infrastructure as code manages environment setup through versioned code. It improves repeatability, auditing, and automation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a container?", Back = "A container packages an application and its dependencies into an isolated runtime. It provides consistent behavior across environments.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is Kubernetes?", Back = "Kubernetes orchestrates container deployment, scaling, and management. It automates scheduling, health checks, and service discovery.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a message broker?", Back = "A message broker routes messages between producers and consumers. It decouples services and supports asynchronous processing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a cron job?", Back = "A cron job is a scheduled task that runs at specific times. It is used for recurring maintenance or batch work.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a feature branch?", Back = "A feature branch isolates work on a specific change. It keeps the main branch stable while development continues.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is Git rebase?", Back = "Git rebase moves commits to a new base to produce a linear history. It can simplify history but should be used carefully on shared branches.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is pair programming?", Back = "Pair programming has two developers collaborate at one workstation. It improves code quality and knowledge sharing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a technical specification?", Back = "A technical specification describes a feature’s design, tradeoffs, and implementation plan. It aligns stakeholders before development begins.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a linked list?", Back = "A linked list is a linear collection of nodes where each node points to the next. It provides cheap insertions/removals but slower indexing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Array vs linked list tradeoff.", Back = "Arrays provide O(1) indexing but costly inserts/removals in the middle. Linked lists provide fast inserts/removals but O(n) indexing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a binary tree?", Back = "A binary tree is a tree where each node has up to two children. It is the foundation for many search and ordering structures.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a binary search tree?", Back = "A binary search tree maintains ordering so left < node < right. It enables efficient search, insert, and delete when balanced.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a heap?", Back = "A heap is a tree-based structure with a heap-order property. It is commonly used to implement priority queues.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a priority queue?", Back = "A priority queue is an abstract data type that removes items by priority. It is often implemented using a heap for efficiency.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is breadth-first search (BFS)?", Back = "BFS visits graph nodes level by level, exploring neighbors first. It is useful for shortest paths in unweighted graphs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is depth-first search (DFS)?", Back = "DFS explores as far as possible along a branch before backtracking. It is useful for topological sorting and cycle detection.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is dynamic programming?", Back = "Dynamic programming solves problems by combining solutions to overlapping subproblems. It trades memory for speed by storing intermediate results.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is memoization?", Back = "Memoization caches results of expensive function calls. It speeds up repeated computations with the same inputs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a trie?", Back = "A trie is a prefix tree optimized for string lookup and autocomplete. It enables fast prefix queries.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a graph?", Back = "A graph is a set of vertices connected by edges. It models relationships such as networks or dependencies.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is topological sort used for?", Back = "Topological sort orders nodes in a DAG based on dependencies. It is used for scheduling and build systems.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a DAG?", Back = "A DAG is a directed acyclic graph with no cycles. It represents dependency structures like workflows or task graphs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is Dijkstra's algorithm used for?", Back = "Dijkstra’s algorithm finds shortest paths with non-negative edge weights. It is a core algorithm for routing and pathfinding.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is A* search?", Back = "A* search is a shortest-path algorithm that uses a heuristic to guide exploration. It is efficient in practice for pathfinding problems.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a hash collision?", Back = "A hash collision occurs when different keys map to the same bucket. Collision resolution strategies are required to maintain correctness.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Open addressing vs chaining.", Back = "Open addressing stores entries within the table itself, probing for open slots. Chaining stores a list of entries per bucket to handle collisions.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a load factor?", Back = "The load factor is the ratio of items to buckets in a hash table. Higher load factors increase collision rates and slow operations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is amortized analysis?", Back = "Amortized analysis averages operation costs over a sequence of operations. It explains why occasional expensive operations can still yield good average performance.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is thread safety?", Back = "Thread safety means code behaves correctly under concurrent access. It typically requires synchronization or immutability.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a critical section?", Back = "A critical section is code that must not be executed by more than one thread at once. It protects shared state from races.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a semaphore?", Back = "A semaphore controls concurrent access by allowing a limited number of permits. It can be used for throttling or resource pooling.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a condition variable?", Back = "A condition variable lets threads wait until a condition is signaled. It is used with locks for coordinated concurrency.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Process vs thread.", Back = "Processes have separate memory spaces, while threads share a process’s memory. Threads are lighter but require careful synchronization.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is context switching?", Back = "Context switching saves and restores CPU state to move between threads or processes. It enables multitasking but adds overhead.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is virtual memory?", Back = "Virtual memory maps virtual addresses to physical memory via the OS. It allows isolation and the illusion of large address spaces.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is paging?", Back = "Paging divides memory into fixed-size pages for virtual memory management. It enables efficient allocation and swapping.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a memory-mapped file?", Back = "A memory-mapped file maps file contents into memory for direct access. It can improve performance for large files and random access.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a socket?", Back = "A socket is an endpoint for network communication. It allows processes to send and receive data over a network.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "TCP vs UDP.", Back = "TCP is reliable and ordered, while UDP is faster but unreliable. The choice depends on latency, reliability, and application needs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the TCP three-way handshake?", Back = "The TCP handshake uses SYN, SYN-ACK, and ACK to establish a connection. It ensures both sides are ready and synchronized.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is DNS?", Back = "DNS translates domain names into IP addresses. It is a critical part of internet routing and discovery.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an HTTP header?", Back = "An HTTP header is metadata sent with a request or response. It carries information like content type, caching, and authentication.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is HTTP/2 main benefit?", Back = "HTTP/2 multiplexes many requests over a single connection. This reduces latency and improves performance compared to HTTP/1.1.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is GraphQL?", Back = "GraphQL is a query language for APIs that lets clients request exactly the data they need. It reduces over-fetching and under-fetching.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is gRPC?", Back = "gRPC is a high-performance RPC framework using Protobuf and HTTP/2. It supports streaming and strong typing across services.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "JSON vs Protobuf.", Back = "JSON is human-readable and widely supported. Protobuf is compact, faster to parse, and more efficient on the wire.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is serialization?", Back = "Serialization converts objects into a storable or transmittable format. It enables persistence and cross-process communication.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is deserialization?", Back = "Deserialization reconstructs objects from a serialized format. It must validate inputs to avoid security issues.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "PUT vs POST.", Back = "PUT is typically idempotent for create or replace operations. POST is used for create operations where the server assigns the identifier.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is pagination?", Back = "Pagination splits large result sets into pages using limit/offset or cursors. It improves performance and user experience.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is CORS?", Back = "CORS is a browser security mechanism that controls cross-origin requests. It helps prevent unauthorized access from other domains.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is OAuth 2.0?", Back = "OAuth 2.0 is a standard for delegated authorization without sharing passwords. It is widely used for third-party access.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a JWT?", Back = "A JWT is a signed token that carries claims for authentication or authorization. It is compact and often used in stateless APIs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is TLS?", Back = "TLS encrypts data in transit to protect confidentiality and integrity. It underpins HTTPS and secure communications.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is SQL injection?", Back = "SQL injection is an attack that manipulates queries via unsanitized input. It is prevented with parameterized queries and proper validation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is XSS?", Back = "XSS injects malicious scripts into web pages viewed by users. It is mitigated through output encoding and content security policies.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is CSRF?", Back = "CSRF tricks a user into making unintended requests while authenticated. Mitigations include anti-CSRF tokens and same-site cookies.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is RBAC?", Back = "RBAC controls permissions based on roles assigned to users. It simplifies authorization by grouping permissions logically.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is SSO?", Back = "SSO allows users to sign in once and access multiple applications. It improves user experience and centralizes authentication.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "CI vs CD.", Back = "CI automates building and testing, while CD automates delivery or deployment. Together they accelerate reliable releases.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is continuous delivery?", Back = "Continuous delivery keeps software in a deployable state at all times. Releases are manual but low-risk and routine.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is continuous deployment?", Back = "Continuous deployment automatically releases every change that passes tests. It requires strong automation and monitoring.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a rollback?", Back = "A rollback reverts to a previous version after a bad release. It is a key safety mechanism in deployment strategies.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a blue/green deployment?", Back = "Blue/green deployment runs two environments and switches traffic between them. It enables quick rollback and minimizes downtime.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a canary release?", Back = "A canary release gradually rolls out to a small percentage of users. It reduces risk by validating behavior before full rollout.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is code coverage?", Back = "Code coverage measures the percentage of code executed by tests. It is a useful signal but not a guarantee of correctness.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is mocking?", Back = "Mocking replaces dependencies with controllable test doubles. It helps isolate behavior and verify interactions.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Stub vs mock.", Back = "A stub returns predefined data for testing. A mock also verifies that expected interactions occurred.", CreatedAt = now, UpdatedAt = now }
        };
        await db.InsertAllAsync(cards);
    }
    public static async Task EnsureSystemDesignDeckAsync(SQLiteAsyncConnection db)
    {
        var existing = await db.Table<Deck>()
            .Where(d => d.Name == "System Design")
            .FirstOrDefaultAsync();

        if (existing is not null)
        {
            return;
        }

        var now = DateTime.UtcNow;
        var deck = new Deck
        {
            Name = "System Design",
            CreatedAt = now,
            UpdatedAt = now
        };

        await db.InsertAsync(deck);

        var cards = new List<Card>
        {
            new() { DeckId = deck.Id, Front = "Define system design.", Back = "System design defines the components, data flow, and interfaces of a system. It balances tradeoffs like scalability, reliability, and cost to meet requirements.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are functional requirements?", Back = "Functional requirements describe what the system must do for users. They are expressed as features, behaviors, or API capabilities.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are non-functional requirements?", Back = "Non-functional requirements are constraints on performance and operation, such as latency, availability, throughput, security, and cost. They guide architecture and tradeoffs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define scalability.", Back = "Scalability is the ability to handle increasing load by adding resources without degrading performance. It depends on architecture, data design, and operational strategy.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Horizontal vs vertical scaling.", Back = "Horizontal scaling adds more machines or instances to share load. Vertical scaling increases the power of a single machine (CPU/RAM), which has practical limits.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is load balancing?", Back = "Load balancing distributes incoming requests across instances to improve availability and throughput. It also enables failover by routing around unhealthy nodes.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a reverse proxy?", Back = "A reverse proxy sits in front of backend services and forwards client requests to them. It can also handle TLS termination, caching, and routing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define caching.", Back = "Caching stores frequently accessed data so future requests are faster and cheaper. The key challenges are choosing what to cache and when to invalidate.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Cache aside pattern.", Back = "In cache-aside, the application checks the cache first and falls back to the DB on a miss. After fetching, it writes the result to the cache for subsequent requests.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Write-through vs write-back cache.", Back = "Write-through updates cache and DB at the same time for stronger consistency. Write-back updates the cache first and persists to DB later, improving performance but increasing risk.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a CDN?", Back = "A CDN is a geographically distributed network of edge servers that cache content near users. It reduces latency and offloads traffic from the origin.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define replication.", Back = "Replication keeps multiple copies of data across nodes to improve availability and read scaling. It introduces challenges like lag and consistency management.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define sharding.", Back = "Sharding partitions data across nodes using a shard key so each node handles a subset. It improves write and storage scalability but complicates queries and rebalancing.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "CAP theorem.", Back = "CAP says that under network partitions, a system must choose between consistency and availability. Real systems decide where to land on this tradeoff based on requirements.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Strong vs eventual consistency.", Back = "Strong consistency means reads always see the latest write. Eventual consistency allows temporary divergence but converges over time, often with higher availability.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is idempotency?", Back = "An idempotent operation can be repeated without changing the result beyond the first application. It is critical for safe retries in distributed systems.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is rate limiting?", Back = "Rate limiting restricts how many requests a user/IP can make in a time window. It protects services from overload and abuse while ensuring fair usage.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is backpressure?", Back = "Backpressure slows producers when consumers are overwhelmed to prevent cascading failures. It keeps queues bounded and stabilizes the system.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define message queue.", Back = "A message queue buffers work so producers and consumers are decoupled in time and scale. It enables async processing and improves resilience.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "At-least-once vs at-most-once delivery.", Back = "At-least-once delivery ensures messages arrive but may create duplicates. At-most-once avoids duplicates but may drop messages, so consumers must choose tradeoffs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a dead letter queue?", Back = "A dead letter queue holds messages that repeatedly fail processing. It enables inspection, alerting, and manual or automated remediation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define SLO and SLA.", Back = "An SLO is the internal reliability target for a service metric. An SLA is the external contractual commitment, often with penalties if the SLO is missed.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an API gateway?", Back = "An API gateway is the centralized entry point for client requests to backend services. It handles routing, authentication, rate limiting, and sometimes aggregation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define observability.", Back = "Observability is the ability to understand a system’s internal state from its outputs. It relies on logs, metrics, and traces to explain behavior and diagnose issues.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Blue/green deployment.", Back = "Blue/green deployment runs two environments so you can switch traffic with minimal downtime. It reduces risk by enabling fast rollback to the previous version.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Canary release.", Back = "A canary release rolls out changes to a small subset of users first. It limits blast radius while you observe real-world behavior before full rollout.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a circuit breaker?", Back = "A circuit breaker stops calls to a failing service after a threshold of errors. It prevents cascading failures and allows recovery before retrying.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define bulkhead isolation.", Back = "Bulkhead isolation partitions resources so failures are contained to a subset of the system. It prevents one overloaded component from taking down others.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is CQRS?", Back = "CQRS separates read models from write models to optimize each independently. It is useful when read and write workloads have different performance or scaling needs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is event sourcing?", Back = "Event sourcing persists state as an append-only log of events rather than storing current state directly. You reconstruct state by replaying events, which enables auditability and temporal queries.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Monolith vs microservices.", Back = "A monolith is a single deployable unit with tightly coupled components. Microservices split functionality into independently deployable services with clearer boundaries.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "When to choose microservices?", Back = "Choose microservices when domain boundaries are clear and teams need independent scaling or deployment. The tradeoff is higher operational complexity and distributed coordination.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is service discovery?", Back = "Service discovery lets services find each other dynamically without hardcoding addresses. It is typically backed by a registry and health checks.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a distributed lock?", Back = "A distributed lock ensures single ownership of a resource across multiple nodes. It prevents concurrent conflicting operations but must handle timeouts and failures safely.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Leader election.", Back = "Leader election chooses a single node to coordinate or make decisions in a cluster. It simplifies coordination but requires reliable failure detection.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is consistent hashing?", Back = "Consistent hashing distributes keys across nodes while minimizing remapping when nodes change. It is commonly used for caches and sharded storage.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define hot partition.", Back = "A hot partition is a shard receiving disproportionate traffic or data volume. It can become a bottleneck and often requires rebalancing or key redesign.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Read replicas: tradeoffs.", Back = "Read replicas improve read throughput and reduce load on the primary. They introduce replication lag and consistency challenges for read-after-write use cases.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Multi-region deployment.", Back = "Multi-region deployment serves users from multiple geographic regions for lower latency and resilience. It increases complexity around data consistency and failover.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "RTO vs RPO.", Back = "RTO is the maximum acceptable time to restore service after an outage. RPO is the maximum acceptable data loss, measured as time between backups or replicas.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a schema migration strategy?", Back = "A good migration strategy uses backward- and forward-compatible changes with staged rollouts. It minimizes downtime and allows safe rollback.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define P99 latency.", Back = "P99 latency is the threshold that 99% of requests complete under. It captures tail performance that users notice more than averages.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is tail latency?", Back = "Tail latency refers to the slowest requests at high percentiles like P95 or P99. It can dominate user experience even if the median is fast.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is request hedging?", Back = "Request hedging sends duplicate requests to reduce the impact of slow replicas. It can lower tail latency but increases load and cost.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is data denormalization?", Back = "Denormalization stores redundant data to speed reads. It improves query performance but increases write complexity and risk of inconsistency.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a read-through cache?", Back = "A read-through cache automatically loads data from the backing store on a cache miss. It simplifies application code but can hide slow storage under load.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is write-behind caching?", Back = "Write-behind buffers writes in cache and persists to the DB asynchronously. It improves write latency but risks data loss if the cache fails.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is cache stampede?", Back = "A cache stampede happens when many requests miss simultaneously and overwhelm the DB. Mitigations include request coalescing, locking, or staggered expirations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Cache eviction strategies.", Back = "Common strategies include LRU, LFU, FIFO, and TTL-based eviction. The best choice depends on access patterns and memory constraints.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is read-your-writes consistency?", Back = "Read-your-writes consistency guarantees a client sees its own most recent writes. It is important for user-facing workflows that depend on immediate feedback.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is quorum in distributed systems?", Back = "A quorum is a majority of nodes that must agree for an operation to complete. It balances consistency and availability in replicated systems.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Leader-follower replication.", Back = "In leader-follower replication, the leader handles writes and followers replicate and serve reads. It simplifies conflict handling but can create a write bottleneck.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is log compaction?", Back = "Log compaction removes redundant records while preserving the latest state for each key. It keeps logs smaller without losing essential history.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a write-ahead log?", Back = "A write-ahead log records changes before they are applied to the database. It improves durability and supports recovery after crashes.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a two-phase commit?", Back = "Two-phase commit coordinates multiple participants to either all commit or all roll back. It provides atomicity but can be slow and block during failures.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is eventual leader election?", Back = "Eventual leader election means nodes will converge to a single leader after failures or partitions heal. During instability, temporary split leadership can occur.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is split brain?", Back = "Split brain occurs when two nodes both believe they are the leader due to network partition. It can cause conflicting writes and data corruption if not prevented.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a distributed consensus algorithm?", Back = "Distributed consensus algorithms like Raft or Paxos help nodes agree on shared state. They are foundational for leader election and replicated logs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Define eventual consistency window.", Back = "The eventual consistency window is the time it takes replicas to converge after a write. Shorter windows improve user experience but often cost more resources.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is read repair?", Back = "Read repair fixes stale replicas during a read by updating out-of-date copies. It improves consistency over time without a separate repair process.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is hinted handoff?", Back = "Hinted handoff temporarily stores writes intended for an unavailable replica. When the replica returns, the stored writes are replayed.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a service mesh?", Back = "A service mesh is an infrastructure layer for service-to-service communication. It typically provides traffic management, security, and observability via sidecars.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is sidecar pattern?", Back = "The sidecar pattern runs a helper process alongside each service instance. It handles cross-cutting concerns like networking, auth, or logging without changing application code.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is API rate limiting by token bucket?", Back = "Token bucket rate limiting refills tokens at a steady rate and consumes one per request. It allows short bursts while enforcing a long-term rate.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is leaky bucket rate limiting?", Back = "Leaky bucket queues requests and releases them at a fixed rate. It smooths traffic but can increase latency under bursts.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is autoscaling?", Back = "Autoscaling adjusts instance count based on load or metrics. It improves resilience and cost efficiency when demand fluctuates.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is graceful degradation?", Back = "Graceful degradation reduces non-critical features under load to preserve core functionality. It keeps the system usable during partial failures.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is circuit breaker half-open state?", Back = "The half-open state allows a small number of test requests to probe recovery. If they succeed, the circuit closes; if they fail, it reopens.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a health check?", Back = "A health check is an endpoint used to verify service liveness or readiness. It helps load balancers and orchestrators make routing decisions.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Liveness vs readiness probe.", Back = "Liveness probes indicate whether a service should be restarted. Readiness probes indicate whether it can safely receive traffic.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is data partitioning by range?", Back = "Range partitioning shards data by key ranges (e.g., A–F, G–L). It supports efficient range queries but can create hot spots.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is data partitioning by hash?", Back = "Hash partitioning distributes keys evenly across shards by hashing. It balances load but makes range queries harder.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is hot standby?", Back = "A hot standby is a replica kept up to date and ready to take over immediately. It reduces failover time at the cost of extra resources.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is failover?", Back = "Failover is the process of switching to a standby after a primary failure. It aims to minimize downtime and data loss.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a read/write split?", Back = "A read/write split sends writes to the primary and reads to replicas. It improves read scalability but introduces replication lag concerns.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a data lake?", Back = "A data lake is centralized storage for raw structured and unstructured data. It supports flexible analytics but requires strong governance.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a data warehouse?", Back = "A data warehouse is an optimized store for analytics and reporting. It typically contains cleaned, modeled data for BI workloads.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is ETL?", Back = "ETL extracts data from sources, transforms it, and loads it into a target system. It is common in data warehousing pipelines.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Batch vs stream processing.", Back = "Batch processing handles data in periodic jobs, while stream processing handles continuous events. Streaming reduces latency but increases complexity.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is exactly-once processing?", Back = "Exactly-once processing ensures each message affects results only once. It requires careful coordination to avoid duplicates or loss.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is backfill?", Back = "Backfill reprocesses historical data to correct or enrich results. It is often used after bug fixes or schema changes.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is schema-on-read?", Back = "Schema-on-read applies structure when data is read rather than when it is written. It provides flexibility but can shift complexity to consumers.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a data retention policy?", Back = "A data retention policy defines how long data is stored before deletion or archival. It balances compliance, cost, and operational needs.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is SSO vs federation?", Back = "SSO lets users sign in once across multiple apps. Federation means trusting external identity providers to authenticate users.", CreatedAt = now, UpdatedAt = now }
        };

        await db.InsertAllAsync(cards);
    }

    public static async Task EnsureCSharpDeckAsync(SQLiteAsyncConnection db)
    {
        var existing = await db.Table<Deck>()
            .Where(d => d.Name == "CSharp")
            .FirstOrDefaultAsync();

        if (existing is not null)
        {
            return;
        }

        var now = DateTime.UtcNow;
        var deck = new Deck
        {
            Name = "CSharp",
            CreatedAt = now,
            UpdatedAt = now
        };

        await db.InsertAsync(deck);

        var cards = new List<Card>
        {
            new() { DeckId = deck.Id, Front = "What is C#?", Back = "C# is a modern, object-oriented language designed for the .NET platform. It combines strong typing with productivity features like LINQ and async/await.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the CLR?", Back = "The CLR (Common Language Runtime) executes .NET code and enforces type safety. It also provides services like garbage collection, JIT compilation, and security checks.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is CTS?", Back = "The CTS (Common Type System) defines how types are declared and used in .NET. It enables cross-language interoperability by standardizing type rules.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is CLS?", Back = "The CLS (Common Language Specification) is a subset of CTS rules that all .NET languages can follow. It ensures libraries are usable across languages.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is IL?", Back = "IL (Intermediate Language) is the CPU-agnostic bytecode produced by the compiler. The CLR later JIT-compiles IL into native machine code.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is JIT compilation?", Back = "JIT (Just-In-Time) compilation turns IL into native machine code at runtime. It enables runtime optimizations based on the executing environment.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is managed code?", Back = "Managed code runs under the CLR, which provides services like garbage collection and exception handling. It contrasts with unmanaged code that runs outside the CLR’s control.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a namespace?", Back = "A namespace organizes types into logical groups to avoid name collisions. It also improves readability by signaling ownership or domain.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an assembly?", Back = "An assembly is the compiled unit of deployment in .NET, such as a DLL or EXE. It contains IL, metadata, and versioning information.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Class vs struct.", Back = "Classes are reference types allocated on the heap, while structs are value types typically allocated on the stack. Structs avoid heap allocations but can be costly to copy if large.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a record?", Back = "A record is a type optimized for immutability and value-based equality. It is useful for DTOs and domain models where identity is defined by data.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an interface?", Back = "An interface defines a contract of members without implementation. Types implement interfaces to enable polymorphism and dependency inversion.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an abstract class?", Back = "An abstract class provides shared behavior and can define abstract members. It cannot be instantiated and is meant to be subclassed.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "virtual vs override.", Back = "A virtual member provides a default implementation that can be changed. An override replaces that implementation in a derived class.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a sealed class?", Back = "A sealed class cannot be inherited. It can improve performance and prevents unwanted extension.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a partial class?", Back = "A partial class splits a single type across multiple files. It is useful for code generation and keeping concerns separated.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a static class?", Back = "A static class cannot be instantiated and contains only static members. It is commonly used for utility or helper methods.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an extension method?", Back = "An extension method is a static method that appears as an instance method on an existing type. It adds functionality without modifying the original type.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a property?", Back = "A property exposes data through get/set accessors. It allows validation or logic while keeping a field encapsulated.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an auto-implemented property?", Back = "An auto-property lets the compiler generate the backing field. It is concise when no extra logic is needed in get or set.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an indexer?", Back = "An indexer lets an object be accessed with array-like syntax. It provides a natural API for collection-like types.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a constructor?", Back = "A constructor initializes a new object and sets up invariants. It can be overloaded to support different initialization paths.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a static constructor?", Back = "A static constructor initializes a type before its first use. It runs once and is commonly used for static setup.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a readonly field?", Back = "A readonly field can be assigned only at declaration or in a constructor. It prevents changes after initialization and improves immutability.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "const vs readonly.", Back = "const values are compile-time constants embedded into callers. readonly values are evaluated at runtime and can be set in constructors.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "ref vs out vs in.", Back = "ref passes a variable by reference for read/write. out is for write-only initialization, while in passes by reference as readonly.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Value types vs reference types.", Back = "Value types store data directly and are copied on assignment. Reference types store a reference to data on the heap and share that instance.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is boxing/unboxing?", Back = "Boxing converts a value type to an object on the heap. Unboxing extracts the value type, which can be costly if done frequently.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are nullable reference types?", Back = "Nullable reference types add annotations to express when null is allowed. They help the compiler warn about potential null dereferences.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are nullable value types?", Back = "Nullable value types allow value types like int to represent null (e.g., int?). They are implemented as a wrapper struct under the hood.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are generics?", Back = "Generics let you define type parameters for reusable, type-safe code. They reduce duplication and avoid runtime casting.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are generic constraints?", Back = "Generic constraints restrict which types can be used for a type parameter. They allow the compiler to enforce capabilities like reference type, new(), or interface implementation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "IEnumerable vs IQueryable.", Back = "IEnumerable executes in memory and works well for local collections. IQueryable translates expression trees to remote queries, such as SQL.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "IEnumerable vs IEnumerator.", Back = "IEnumerable provides an enumerator to iterate a collection. IEnumerator is the actual iterator that maintains the current position.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is LINQ?", Back = "LINQ is a query syntax and API for filtering, projecting, and aggregating data. It works with in-memory collections and query providers like EF.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is deferred execution?", Back = "Deferred execution means a LINQ query runs only when enumerated. It allows composition but can also hide expensive operations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a lambda expression?", Back = "A lambda expression is an inline anonymous function, such as x => x + 1. It is often used with LINQ and delegates.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an expression tree?", Back = "An expression tree represents code as data structures rather than executing it. Providers like LINQ to SQL use it to translate C# into queries.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a delegate?", Back = "A delegate is a type-safe reference to a method signature. It enables passing methods as parameters and building callbacks.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an event?", Back = "An event is a delegate with restricted invocation, so only the declaring type can raise it. It enables publish/subscribe patterns in C#.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a multicast delegate?", Back = "A multicast delegate can invoke multiple methods in sequence. It is the basis of event invocation in .NET.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the event handler pattern?", Back = "The event handler pattern uses an object sender and EventArgs (or a derived type). It standardizes how events are raised and handled.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "How does try/catch/finally work?", Back = "The try block runs the protected code, catch handles exceptions, and finally runs regardless of success or failure. It is used for cleanup, such as releasing resources.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does using statement do?", Back = "The using statement ensures IDisposable is disposed at the end of a scope. It is commonly used with streams, database connections, and other resources.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is IDisposable?", Back = "IDisposable defines a Dispose method for releasing unmanaged resources deterministically. It enables the using pattern for predictable cleanup.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a finalizer?", Back = "A finalizer (destructor) runs during garbage collection to clean unmanaged resources. It is non-deterministic and generally a last-resort cleanup mechanism.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are GC generations?", Back = "The GC groups objects into generations (0, 1, 2) based on age. Younger generations are collected more frequently for efficiency.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is async/await?", Back = "async/await is the C# asynchronous programming model built around Tasks. It allows writing non-blocking code that reads like synchronous code.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Task vs ValueTask.", Back = "Task is a reference type used for most async operations. ValueTask can avoid allocations in high-throughput scenarios but is more complex to use correctly.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does ConfigureAwait(false) do?", Back = "ConfigureAwait(false) avoids capturing the current synchronization context. It improves performance in library code but should be used carefully in UI apps.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Why avoid async void?", Back = "async void methods cannot be awaited and surface exceptions to the synchronization context. They are generally reserved for event handlers only.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is CancellationToken?", Back = "A CancellationToken provides a cooperative way to cancel asynchronous operations. It lets callers signal cancellation and callee code observe and stop.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does lock do?", Back = "lock ensures only one thread at a time can execute a critical section. It prevents race conditions by synchronizing access to shared state.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Monitor vs lock.", Back = "lock is syntax sugar for Monitor.Enter/Exit with exception-safe release. Monitor also provides advanced features like Wait and Pulse.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does volatile mean?", Back = "volatile prevents certain compiler and CPU reordering for a field. It ensures reads and writes go directly to memory, but it does not make operations atomic.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is Interlocked?", Back = "Interlocked provides atomic operations like increment, exchange, and compare-exchange. It is used for lock-free thread-safe updates.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Thread vs Task.", Back = "A thread is an OS-level execution unit, while a Task is a higher-level abstraction for asynchronous work. Tasks often run on thread-pool threads and support composition.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Concurrency vs parallelism.", Back = "Concurrency is managing multiple tasks that can make progress independently. Parallelism means executing tasks simultaneously on multiple cores.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is IAsyncEnumerable?", Back = "IAsyncEnumerable enables asynchronous streaming of data with await foreach. It is useful for large or remote sequences that produce items over time.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is pattern matching?", Back = "Pattern matching checks the shape or type of data and can extract values. It makes code clearer by combining checks with deconstruction.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a switch expression?", Back = "A switch expression is an expression-based form of switch that returns a value. It is concise and works well with pattern matching.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is ?? operator?", Back = "The null-coalescing operator returns the left operand if it is not null, otherwise the right. It provides a concise fallback for nullable values.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is ?. operator?", Back = "The null-conditional operator safely accesses a member if the receiver is not null. It prevents NullReferenceException by short-circuiting to null.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the ! operator for nulls?", Back = "The null-forgiving operator tells the compiler to ignore nullability warnings. It does not change runtime behavior, so it should be used sparingly.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does nameof do?", Back = "nameof returns the name of a variable, type, or member as a string. It is refactoring-safe and commonly used in exceptions and logging.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does var mean?", Back = "var lets the compiler infer the local variable type from the assignment. It does not make the variable dynamically typed.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is dynamic?", Back = "dynamic defers type resolution to runtime instead of compile time. It offers flexibility but can introduce runtime errors and overhead.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does 'is' do?", Back = "The is operator checks type compatibility and supports pattern matching. It can both test and assign in a single expression.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a tuple?", Back = "A tuple is a lightweight grouping of multiple values into a single object. It is useful for returning multiple values without defining a custom type.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is deconstruction?", Back = "Deconstruction unpacks values from tuples or types into separate variables. It improves readability when extracting multiple values at once.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "record class vs record struct.", Back = "record class is a reference type with value-based equality semantics. record struct is a value type with similar semantics and avoids heap allocations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an init-only setter?", Back = "An init-only setter allows a property to be set during object initialization only. It supports immutability while keeping object initializers convenient.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is the required keyword?", Back = "The required keyword forces callers to initialize a property during object creation. It improves correctness by preventing partially initialized objects.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are top-level statements?", Back = "Top-level statements allow program entry without an explicit Main method. They reduce boilerplate for small programs and scripts.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are global usings?", Back = "Global usings apply using directives across all files in a project. They reduce repetitive imports and simplify project templates.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a file-scoped namespace?", Back = "A file-scoped namespace applies to the entire file with a single line declaration. It reduces indentation and keeps code cleaner.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a using alias?", Back = "A using alias assigns a short name to a namespace or type. It helps resolve naming conflicts and improves readability.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are attributes?", Back = "Attributes are metadata annotations applied to code elements. They enable behaviors such as serialization rules, validation, and tooling hints.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is reflection?", Back = "Reflection inspects types and metadata at runtime. It enables dynamic discovery but can be slower and harder to reason about.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is serialization?", Back = "Serialization converts objects to a storable or transmittable format like JSON or binary. Deserialization reconstructs the object from that format.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is Span<T>?", Back = "Span<T> is a stack-only view over contiguous memory. It enables high-performance slicing without allocations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is Memory<T>?", Back = "Memory<T> is a heap-safe counterpart to Span<T> that can be stored and used across async calls. It provides similar slicing capabilities with fewer lifetime constraints.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is StringBuilder for?", Back = "StringBuilder efficiently builds strings when there are many modifications. It avoids repeated allocations that occur with concatenation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is string interpolation?", Back = "String interpolation embeds expressions directly into strings using $\"{expr}\". It improves readability compared to string.Format or concatenation.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a verbatim string?", Back = "A verbatim string literal begins with @ and ignores escape sequences. It is useful for file paths and multi-line text.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Why are strings immutable?", Back = "Strings are immutable for safety, sharing, and performance optimizations like interning. It prevents unexpected changes when the same string instance is shared.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "DateTime vs DateTimeOffset.", Back = "DateTime represents a time without an offset, while DateTimeOffset includes the UTC offset. DateTimeOffset is preferred for storing absolute points in time.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an enum?", Back = "An enum is a set of named constants backed by an integral type. It improves readability and type safety for discrete values.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a [Flags] enum?", Back = "A [Flags] enum represents a bit field where values can be combined. It enables efficient storage of multiple boolean options.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does checked do?", Back = "checked enables overflow checking for arithmetic operations. It throws an exception if the result overflows the numeric type.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What does unchecked do?", Back = "unchecked disables overflow checking for arithmetic operations. It allows wraparound behavior for performance or low-level scenarios.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is operator overloading?", Back = "Operator overloading lets types define custom behavior for operators like + or ==. It should be used sparingly to keep code intuitive.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "Implicit vs explicit operators.", Back = "Implicit operators allow conversions without a cast. Explicit operators require a cast to make conversions obvious and safer.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are index and range?", Back = "Index (^) and range (..) provide concise slicing and indexing of collections. They simplify substring and array slicing operations.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are nullable annotations?", Back = "Nullable annotations use ? and ! to express nullability intent. They help the compiler detect potential null misuse.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a with expression?", Back = "A with expression creates a copy of a record with specified modifications. It is useful for immutability-friendly updates.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is a collection initializer?", Back = "Collection initializers add items to a collection at creation time. They improve readability by keeping construction concise.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What is an object initializer?", Back = "Object initializers set properties during object creation without explicit constructors. They keep initialization code compact and readable.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are property accessors?", Back = "Property accessors are the get and set blocks that control access to a property. They can include validation, transformation, or access control logic.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are expression-bodied members?", Back = "Expression-bodied members use => for concise single-expression implementations. They reduce boilerplate for simple properties or methods.", CreatedAt = now, UpdatedAt = now },
            new() { DeckId = deck.Id, Front = "What are tuple element names?", Back = "Tuple element names label items like (int id, string name) for readability. They travel with the tuple to improve clarity in use.", CreatedAt = now, UpdatedAt = now }
        };

        await db.InsertAllAsync(cards);
    }
}
